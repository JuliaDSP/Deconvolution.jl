<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Deconvolution.jl · Deconvolution.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Deconvolution.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Deconvolution.jl</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Development"><span>Development</span></a></li><li><a class="tocitem" href="#License"><span>License</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Deconvolution.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Deconvolution.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDSP/Deconvolution.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Deconvolution.jl"><a class="docs-heading-anchor" href="#Deconvolution.jl">Deconvolution.jl</a><a id="Deconvolution.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Deconvolution.jl" title="Permalink"></a></h1><hr/><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p><a href="https://github.com/JuliaDSP/Deconvolution.jl">Deconvolution.jl</a> provides a set of functions to <a href="https://en.wikipedia.org/wiki/Deconvolution">deconvolve</a> digital signals, like images or time series. This is written in <a href="http://julialang.org/">Julia</a>, a modern high-level, high-performance dynamic programming language designed for technical computing.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>The latest version of <code>Deconvolution.jl</code> is available for Julia 1.0 and later versions, and can be installed with <a href="https://julialang.github.io/Pkg.jl/stable/">Julia built-in package manager</a>. In a Julia session, after entering the package manager mode with ], run the command</p><pre><code class="language- sourceCode hljs">pkg&gt; add Deconvolution</code></pre><p>Older versions are also available for Julia 0.4-0.7.</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>Currently <code>Deconvolution.jl</code> provides only two methods, but others will hopefully come in the future.</p><h3 id="wiener-function"><a class="docs-heading-anchor" href="#wiener-function"><code>wiener</code> function</a><a id="wiener-function-1"></a><a class="docs-heading-anchor-permalink" href="#wiener-function" title="Permalink"></a></h3><p>The <a href="https://en.wikipedia.org/wiki/Wiener_deconvolution">Wiener deconvolution</a> attempts at reducing the noise in a digital signal by suppressing frequencies with low <a href="https://en.wikipedia.org/wiki/Signal-to-noise_ratio">signal-to-noise ratio</a>. The signal is assumed to be degraded by additive noise and a shift-invariant blurring function.</p><p>Theoretically, the Wiener deconvolution method requires the knowledge of the original signal, the blurring function, and the noise. However, these conditions are difficult to met (and, of course, if you know the original signal you do not need to perform a deconvolution in order to recover the signal itself), but a strength of the Wiener deconvolution is that it works in the frequency domain, so you only need to know with good precision the power spectra of the signal and the noise. In addition, most signals of the same class have fairly similar power spectra and the Wiener filter is insensitive to small variations in the original signal power spectrum. For these reasons, it is possible to estimate the original signal power spectrum using a representative of the class of signals being filtered.</p><p>For a short review of the Wiener deconvolution method see <a href="http://www.dmf.unisalento.it/~giordano/allow_listing/wiener.pdf">http://www.dmf.unisalento.it/~giordano/allow_listing/wiener.pdf</a> and references therein.</p><p>The wiener function can be used to apply the Wiener deconvolution method to a digital signal. The arguments are:</p><ul><li><code>input</code>: the digital signal</li><li><code>signal</code>: the original signal (or a signal with a likely similar   power spectrum)</li><li><code>noise</code>: the noise of the signal (or a noise with a likely similar   power spectrum)</li><li><code>blurring</code> (optional argument): the blurring kernel</li></ul><p>All arguments must be arrays, all with the same size, and all of them in the time/space domain (they will be converted to the frequency domain internally using <code>fft</code> function). Argument <code>noise</code> can be also a real number, in which case a constant noise with that value will be assumed (this is a good approximation in the case of <a href="https://en.wikipedia.org/wiki/White_noise">white noise</a>).</p><h3 id="lucy-function"><a class="docs-heading-anchor" href="#lucy-function"><code>lucy</code> function</a><a id="lucy-function-1"></a><a class="docs-heading-anchor-permalink" href="#lucy-function" title="Permalink"></a></h3><p>The <a href="https://en.wikipedia.org/wiki/Richardson-Lucy_deconvolution">Richardson-Lucy deconvolution</a> is an iterative method based on Bayesian inference for restoration of signal that is convolved with a point spread function.</p><p>The <code>lucy</code> function can be used to apply the Richardson-Lucy deconvolution method to a digital signal. The arguments are:</p><ul><li><code>observed</code>: the digital signal</li><li><code>psf</code>: the point spread function</li><li><code>iterations</code> (optional argument): the number of iterations</li></ul><p>First two arguments must be arrays, all with the same size, and all of them in the time/space domain (they will be converted to the frequency domain internally using <code>fft</code> function). Argument <code>iterations</code> is an integer number. The more iterations is specified the better result should be if the solution converges and it is going to converge if PSF is estimated well.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Wiener-deconvolution"><a class="docs-heading-anchor" href="#Wiener-deconvolution">Wiener deconvolution</a><a id="Wiener-deconvolution-1"></a><a class="docs-heading-anchor-permalink" href="#Wiener-deconvolution" title="Permalink"></a></h3><h4 id="Noisy-time-series"><a class="docs-heading-anchor" href="#Noisy-time-series">Noisy time series</a><a id="Noisy-time-series-1"></a><a class="docs-heading-anchor-permalink" href="#Noisy-time-series" title="Permalink"></a></h4><p>This is an example of application of the Wiener deconvolution to a time series.</p><p>We first construct the noisy signal:</p><pre><code class="language- sourceCode hljs">using LombScargle, Deconvolution, Plots, Statistics
t = range(0, stop=10, length=1000) # observation times
x = sinpi.(t) .* cos.(5 .* t) - 1.5 .* cospi.(t) .* sin.(2 .* t) # the original signal
n = rand(length(x)) # noise to be added
y = x .+ 3 .* (n .- mean(n)) # observed noisy signal</code></pre><p>In order to perform the Wiener deconvolution, we need a signal that has a power spectrum similar to that of the original signal. We can use the <a href="https://en.wikipedia.org/wiki/Least-squares_spectral_analysis">Lomb–Scargle periodogram</a> to find out the dominant frequencies in the observed signal, as implemented in the the Julia package <a href="https://github.com/giordano/LombScargle.jl">LombScargle.jl</a>.</p><pre><code class="language- sourceCode hljs"># Lomb-Scargle periodogram
p = lombscargle(t, y, maximum_frequency=2, samples_per_peak=10)
plot(freqpower(p)...)</code></pre><p>After plotting the periodogram you notice that it has three peaks, one in each of the following intervals: <span>$[0, 0.5]$</span>, <span>$[0.5, 1]$</span>, <span>$[1, 1.5]$</span>. Use the <code>LombScargle.model</code> function to create the best-fitting Lomb–Scargle model at the three best frequencies, that can be found with the <code>findmaxfreq</code> function (see the manual at <a href="http://lombscarglejl.readthedocs.io/">http://lombscarglejl.readthedocs.io/</a> for more details):</p><pre><code class="language- sourceCode hljs">m1 = LombScargle.model(t, y, findmaxfreq(p, [0, 0.5])[1]) # first model
m2 = LombScargle.model(t, y, findmaxfreq(p, [0.5, 1])[1]) # second model
m3 = LombScargle.model(t, y, findmaxfreq(p, [1, 1.5])[1]) # third model</code></pre><p>Once you have these three frequencies, you can deconvolve <code>y</code> by feeding wiener with a simple signal that is the sum of these three models:</p><pre><code class="language- sourceCode hljs">signal = m1 + m2 + m3 # signal for `wiener`
noise = rand(length(y)) # noise for `wiener`
polished = wiener(y, signal, noise)
plot(t, x, size=(900, 600), label=&quot;Original signal&quot;, linewidth=2)
plot!(t, y, label=&quot;Observed signal&quot;)
savefig(&quot;time-series-observed.png&quot;)
plot(t, x, size=(900, 600), label=&quot;Original signal&quot;, linewidth=2)
plot!(t, polished, label=&quot;Recovered with Wiener&quot;)
plot!(t, signal, label=&quot;Lomb–Scargle model&quot;)
savefig(&quot;time-series-recovered.png&quot;)</code></pre><p><img src="wiener/time-series-observed.png" alt="image"/></p><p><img src="wiener/time-series-recovered.png" alt="image"/></p><p>Note that the signal recovered with the Wiener deconvolution is generally a good improvement with respect to the best-fitting Lomb–Scargle model obtained using a few frequencies.</p><p>With real-world data the Lomb–Scargle periodogram may not work as good as in this toy-example, but we showed a possible strategy to create a suitable signal to use with wiener function.</p><h4 id="Blurred-noisy-time-series"><a class="docs-heading-anchor" href="#Blurred-noisy-time-series">Blurred noisy time series</a><a id="Blurred-noisy-time-series-1"></a><a class="docs-heading-anchor-permalink" href="#Blurred-noisy-time-series" title="Permalink"></a></h4><p>Additionally to noise, also a blurring kernel can applied to the image. First we define the blurring kernel as a Gaussian kernel. Using <code>ifftshift</code> we move the center to index position 1 which is required for the Wiener deconvolution algorithm.</p><pre><code class="language- sourceCode hljs"># Gaussian blurring kernel
kernel = exp.( -10 .* (t .- 5) .^ 2)
kernel ./= sum(kernel) # normalize kernel to sum of 1
kernel = ifftshift(kernel) # move center to index pos 1</code></pre><p>The blurring can be applied simply in Fourier space. After the blurring we add the noise.</p><pre><code class="language- sourceCode hljs">y_blurred = real(ifft(fft(kernel) .* fft(x))) + noise</code></pre><p>The deblurred image can be obtained with the following call.</p><pre><code class="language- sourceCode hljs">deblurred = wiener(y_blurred, signal, noise, kernel)</code></pre><p>Additionally to the <code>noise</code> array we also pass <code>kernel</code> to <code>wiener</code>.</p><pre><code class="language- sourceCode hljs">plot(t, x, size=(900, 600), label=&quot;Original signal&quot;, linewidth=2)
plot!(t, deblurred, label=&quot;Deblurred with Wiener&quot;)
savefig(&quot;time-series-deblurred.png&quot;)</code></pre><p><img src="wiener/time-series-observed-blurred.png" alt="image"/></p><p><img src="wiener/time-series-deblurred.png" alt="image"/></p><h4 id="Blurred-image"><a class="docs-heading-anchor" href="#Blurred-image">Blurred image</a><a id="Blurred-image-1"></a><a class="docs-heading-anchor-permalink" href="#Blurred-image" title="Permalink"></a></h4><p>Here is an example of use of wiener function to perform the Wiener deconvolution of an image, degraded with a blurring function and an additive noise.</p><pre><code class="language- sourceCode hljs">using Images, TestImages, Deconvolution, ImageView

# Open the test image
img = float(data(testimage(&quot;cameraman&quot;)))&#39;
# Create the blurring kernel in frequency domain
x = hcat(ntuple(x -&gt; collect((1:512) - 257), 512)...)
k = 0.001
blurring_ft = exp.(-k .* (x .^ 2 .+ x&#39; .^ 2) .^ (5//6))
# Create additive noise
noise = rand(size(img))
# Fourier transform of the blurred image, with additive noise
blurred_img_ft = fftshift(blurring_ft) .* fft(img) + fft(noise)
# Get the blurred image from its Fourier transform
blurred_img = real(ifft(blurred_img_ft))
# Get the blurring kernel in the space domain
blurring = ifft(fftshift(blurring_ft))
# Polish the image with Deconvolution deconvolution
polished = wiener(blurred_img, img, noise, blurring)

# Wiener deconvolution works also when you don&#39;t have the real image and noise,
# that is the most common and useful case.  This happens because the Wiener
# filter only cares about the power spectrum of the signal and the noise, so you
# don&#39;t need to have the exact signal and noise but something with a similar
# power spectrum.
img2 = float(data(testimage(&quot;livingroom&quot;))) # Load another image
noise2 = rand(size(img)) # Create another additive noise
# Polish the image with Deconvolution deconvolution
polished2 = wiener(blurred_img, img2, noise2, blurring)

# Wiener also works using a real number instead of a noise array
polished3 = wiener(blurred_img, img2, 1000, blurring)
polished4 = wiener(blurred_img, img2, 10000, blurring)


# Compare...
view(img) # ...the original image
view(blurred_img) # ...the blurred image
view(polished) # ...the polished image
view(polished2) # ...the second polished image
view(polished3) # ...the third polished image
view(polished4) # ...the fourth polished image</code></pre><table><tr><th style="text-align: left">Original image</th><th style="text-align: left">Blurred image</th></tr><tr><td style="text-align: left"><img src="wiener/original.jpg" alt/></td><td style="text-align: left"><img src="wiener/blurred.jpg" alt/></td></tr></table><table><tr><th style="text-align: left">Image restored with exact power spectrum and noise</th><th style="text-align: left">Image restored with imperfect reference noise and spectrum</th></tr><tr><td style="text-align: left"><img src="wiener/polished.jpg" alt/></td><td style="text-align: left"><img src="wiener/polished2.jpg" alt/></td></tr></table><table><tr><th style="text-align: left">Image restored with imperfect spectrum and constant noise</th><th style="text-align: left">Image restored with imperfect spectrum and constant noise</th></tr><tr><td style="text-align: left"><img src="wiener/polished3.jpg" alt/></td><td style="text-align: left"><img src="wiener/polished4.jpg" alt/></td></tr></table><p>Without knowing the noise array exactly the contrast drops significantly. Some postprocessing of the contrast can enhance the quality further.</p><h3 id="Richardson-Lucy-deconvolution"><a class="docs-heading-anchor" href="#Richardson-Lucy-deconvolution">Richardson-Lucy deconvolution</a><a id="Richardson-Lucy-deconvolution-1"></a><a class="docs-heading-anchor-permalink" href="#Richardson-Lucy-deconvolution" title="Permalink"></a></h3><h4 id="Blurred-image-2"><a class="docs-heading-anchor" href="#Blurred-image-2">Blurred image</a><a class="docs-heading-anchor-permalink" href="#Blurred-image-2" title="Permalink"></a></h4><p>Here is an example of use of <code>lucy</code> function to perform the Richardson-Lucy deconvolution of an image convolved with point spread function that models lens aberration.</p><pre><code class="language- sourceCode hljs">    using Images, TestImages, Deconvolution, FFTW, ZernikePolynomials, ImageView

    img = channelview(testimage(&quot;cameraman&quot;))

    # model of lens aberration
    blurring = evaluateZernike(LinRange(-16,16,512), [12, 4, 0], [1.0, -1.0, 2.0], index=:OSA)
    blurring = fftshift(blurring)
    blurring = blurring ./ sum(blurring)

    blurred_img = fft(img) .* fft(blurring) |&gt; ifft |&gt; real

    @time restored_img_200 = lucy(blurred_img, blurring, iterations=200)
    @time restored_img_2000 = lucy(blurred_img, blurring, iterations=2000)

    imshow(img)
    imshow(blurred_img)
    imshow(restored_img_200)
    imshow(restored_img_2000)</code></pre><table><tr><th style="text-align: left">Original image</th><th style="text-align: left">Blurred image</th></tr><tr><td style="text-align: left"><img src="lucy/original.jpg" alt/></td><td style="text-align: left"><img src="lucy/blurred.jpg" alt/></td></tr></table><table><tr><th style="text-align: left">Result of 200 <code>lucy</code> iterations</th><th style="text-align: left">Result of 2000 <code>lucy</code> iterations</th></tr><tr><td style="text-align: left"><img src="lucy/restored_200.jpg" alt/></td><td style="text-align: left"><img src="lucy/restored_2000.jpg" alt/></td></tr></table><h2 id="Development"><a class="docs-heading-anchor" href="#Development">Development</a><a id="Development-1"></a><a class="docs-heading-anchor-permalink" href="#Development" title="Permalink"></a></h2><p>The package is developed at <a href="https://github.com/JuliaDSP/Deconvolution.jl">https://github.com/JuliaDSP/Deconvolution.jl</a>. There you can submit bug reports, propose new deconvolution methods with pull requests, and make suggestions. If you would like to take over maintainership of the package in order to further improve it, please open an issue.</p><h3 id="History"><a class="docs-heading-anchor" href="#History">History</a><a id="History-1"></a><a class="docs-heading-anchor-permalink" href="#History" title="Permalink"></a></h3><p>The ChangeLog of the package is available in <a href="https://github.com/JuliaDSP/Deconvolution.jl/blob/master/NEWS.md">NEWS.md</a> file in top directory.</p><h2 id="License"><a class="docs-heading-anchor" href="#License">License</a><a id="License-1"></a><a class="docs-heading-anchor-permalink" href="#License" title="Permalink"></a></h2><p>The <code>Deconvolution.jl</code> package is licensed under the MIT &quot;Expat&quot; License. The original author is Mosè Giordano.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Thursday 12 May 2022 22:45">Thursday 12 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
